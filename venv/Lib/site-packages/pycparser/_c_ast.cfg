


















ArrayDecl: [type*, dim*, dim_quals]

ArrayRef: [name*, subscript*]



Assignment: [op, lvalue*, rvalue*]

Alignas: [alignment*]

BinaryOp: [op, left*, right*]

Break: []

Case: [expr*, stmts**]

Cast: [to_type*, expr*]




Compound: [block_items**]






CompoundLiteral: [type*, init*]



Constant: [type, value]

Continue: []









Decl: [name, quals, align, storage, funcspec, type*, init*, bitsize*]

DeclList: [decls**]

Default: [stmts**]

DoWhile: [cond*, stmt*]




EllipsisParam: []



EmptyStatement: []





Enum: [name, values*]



Enumerator: [name, value*]



EnumeratorList: [enumerators**]



ExprList: [exprs**]






FileAST: [ext**]



For: [init*, cond*, next*, stmt*]




FuncCall: [name*, args*]



FuncDecl: [args*, type*]






FuncDef: [decl*, param_decls**, body*]

Goto: [name]

ID: [name]




IdentifierType: [names]

If: [cond*, iftrue*, iffalse*]



InitList: [exprs**]

Label: [name, stmt*]





NamedInitializer: [name**, expr*]



ParamList: [params**]

PtrDecl: [quals, type*]

Return: [expr*]

StaticAssert: [cond*, message*]




Struct: [name, decls**]




StructRef: [name*, type, field*]

Switch: [cond*, stmt*]



TernaryOp: [cond*, iftrue*, iffalse*]



TypeDecl: [declname, quals, align, type*]




Typedef: [name, quals, storage, type*]

Typename: [name, quals, align, type*]

UnaryOp: [op, expr*]




Union: [name, decls**]

While: [cond*, stmt*]

Pragma: [string]
