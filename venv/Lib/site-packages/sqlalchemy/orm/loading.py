








"""private module containing functions used to convert database
rows into object instances and associated state.

the functions here are called primarily by Query, Mapper,
as well as some of the attribute loading strategies.

"""

from __future__ import annotations

from typing import Any
from typing import Dict
from typing import Iterable
from typing import List
from typing import Mapping
from typing import Optional
from typing import Sequence
from typing import Tuple
from typing import TYPE_CHECKING
from typing import TypeVar
from typing import Union

from . import attributes
from . import exc as orm_exc
from . import path_registry
from .base import _DEFER_FOR_STATE
from .base import _RAISE_FOR_STATE
from .base import _SET_DEFERRED_EXPIRED
from .base import PassiveFlag
from .context import FromStatement
from .context import ORMCompileState
from .context import QueryContext
from .util import _none_set
from .util import state_str
from .. import exc as sa_exc
from .. import util
from ..engine import result_tuple
from ..engine.result import ChunkedIteratorResult
from ..engine.result import FrozenResult
from ..engine.result import SimpleResultMetaData
from ..sql import select
from ..sql import util as sql_util
from ..sql.selectable import ForUpdateArg
from ..sql.selectable import LABEL_STYLE_TABLENAME_PLUS_COL
from ..sql.selectable import SelectState
from ..util import EMPTY_DICT

if TYPE_CHECKING:
    from ._typing import _IdentityKeyType
    from .base import LoaderCallableStatus
    from .interfaces import ORMOption
    from .mapper import Mapper
    from .query import Query
    from .session import Session
    from .state import InstanceState
    from ..engine.cursor import CursorResult
    from ..engine.interfaces import _ExecuteOptions
    from ..engine.result import Result
    from ..sql import Select

_T = TypeVar("_T", bound=Any)
_O = TypeVar("_O", bound=object)
_new_runid = util.counter()


_PopulatorDict = Dict[str, List[Tuple[str, Any]]]


def instances(cursor: CursorResult[Any], context: QueryContext) -> Result[Any]:
    """Return a :class:`.Result` given an ORM query context.

    :param cursor: a :class:`.CursorResult`, generated by a statement
     which came from :class:`.ORMCompileState`

    :param context: a :class:`.QueryContext` object

    :return: a :class:`.Result` object representing ORM results

    .. versionchanged:: 1.4 The instances() function now uses
       :class:`.Result` objects and has an all new interface.

    """

    context.runid = _new_runid()

    if context.top_level_context:
        is_top_level = False
        context.post_load_paths = context.top_level_context.post_load_paths
    else:
        is_top_level = True
        context.post_load_paths = {}

    compile_state = context.compile_state
    filtered = compile_state._has_mapper_entities
    single_entity = (
        not context.load_options._only_return_tuples
        and len(compile_state._entities) == 1
        and compile_state._entities[0].supports_single_entity
    )

    try:
        (process, labels, extra) = list(
            zip(
                *[
                    query_entity.row_processor(context, cursor)
                    for query_entity in context.compile_state._entities
                ]
            )
        )

        if context.yield_per and (
            context.loaders_require_buffering
            or context.loaders_require_uniquing
        ):
            raise sa_exc.InvalidRequestError(
                "Can't use yield_per with eager loaders that require uniquing "
                "or row buffering, e.g. joinedload() against collections "
                "or subqueryload().  Consider the selectinload() strategy "
                "for better flexibility in loading objects."
            )

    except Exception:
        with util.safe_reraise():
            cursor.close()

    def _no_unique(entry):
        raise sa_exc.InvalidRequestError(
            "Can't use the ORM yield_per feature in conjunction with unique()"
        )

    def _not_hashable(datatype, *, legacy=False, uncertain=False):
        if not legacy:

            def go(obj):
                if uncertain:
                    try:
                        return hash(obj)
                    except:
                        pass

                raise sa_exc.InvalidRequestError(
                    "Can't apply uniqueness to row tuple containing value of "
                    f"""type {datatype!r}; {
                        'the values returned appear to be'
                        if uncertain
                        else 'this datatype produces'
                    } non-hashable values"""
                )

            return go
        elif not uncertain:
            return id
        else:
            _use_id = False

            def go(obj):
                nonlocal _use_id

                if not _use_id:
                    try:
                        return hash(obj)
                    except:
                        pass




                    _use_id = True

                return id(obj)

            return go

    unique_filters = [
        (
            _no_unique
            if context.yield_per
            else (
                _not_hashable(
                    ent.column.type,  # type: ignore
                    legacy=context.load_options._legacy_uniquing,
                    uncertain=ent._null_column_type,
                )
                if (
                    not ent.use_id_for_hash
                    and (ent._non_hashable_value or ent._null_column_type)
                )
                else id if ent.use_id_for_hash else None
            )
        )
        for ent in context.compile_state._entities
    ]

    row_metadata = SimpleResultMetaData(
        labels, extra, _unique_filters=unique_filters
    )

    def chunks(size):  # type: ignore
        while True:
            yield_per = size

            context.partials = {}

            if yield_per:
                fetch = cursor.fetchmany(yield_per)

                if not fetch:
                    break
            else:
                fetch = cursor._raw_all_rows()

            if single_entity:
                proc = process[0]
                rows = [proc(row) for row in fetch]
            else:
                rows = [
                    tuple([proc(row) for proc in process]) for row in fetch
                ]






            if is_top_level:
                if yield_per:


                    top_level_post_loads = list(
                        context.post_load_paths.items()
                    )

                while context.post_load_paths:
                    post_loads = list(context.post_load_paths.items())
                    context.post_load_paths.clear()
                    for path, post_load in post_loads:
                        post_load.invoke(context, path)

                if yield_per:
                    context.post_load_paths.clear()
                    context.post_load_paths.update(top_level_post_loads)

            yield rows

            if not yield_per:
                break

    if context.execution_options.get("prebuffer_rows", False):



        _prebuffered = list(chunks(None))

        def chunks(size):
            return iter(_prebuffered)

    result = ChunkedIteratorResult(
        row_metadata,
        chunks,
        source_supports_scalars=single_entity,
        raw=cursor,
        dynamic_yield_per=cursor.context._is_server_side,
    )




    result._attributes = result._attributes.union(
        dict(filtered=filtered, is_single_entity=single_entity)
    )


    if context.compile_state.multi_row_eager_loaders:

        def require_unique(obj):
            raise sa_exc.InvalidRequestError(
                "The unique() method must be invoked on this Result, "
                "as it contains results that include joined eager loads "
                "against collections"
            )

        result._unique_filter_state = (None, require_unique)

    if context.yield_per:
        result.yield_per(context.yield_per)

    return result


@util.preload_module("sqlalchemy.orm.context")
def merge_frozen_result(session, statement, frozen_result, load=True):
    """Merge a :class:`_engine.FrozenResult` back into a :class:`_orm.Session`,
    returning a new :class:`_engine.Result` object with :term:`persistent`
    objects.

    See the section :ref:`do_orm_execute_re_executing` for an example.

    .. seealso::

        :ref:`do_orm_execute_re_executing`

        :meth:`_engine.Result.freeze`

        :class:`_engine.FrozenResult`

    """
    querycontext = util.preloaded.orm_context

    if load:

        session._autoflush()

    ctx = querycontext.ORMSelectCompileState._create_entities_collection(
        statement, legacy=False
    )

    autoflush = session.autoflush
    try:
        session.autoflush = False
        mapped_entities = [
            i
            for i, e in enumerate(ctx._entities)
            if isinstance(e, querycontext._MapperEntity)
        ]
        keys = [ent._label_name for ent in ctx._entities]

        keyed_tuple = result_tuple(
            keys, [ent._extra_entities for ent in ctx._entities]
        )

        result = []
        for newrow in frozen_result.rewrite_rows():
            for i in mapped_entities:
                if newrow[i] is not None:
                    newrow[i] = session._merge(
                        attributes.instance_state(newrow[i]),
                        attributes.instance_dict(newrow[i]),
                        load=load,
                        _recursive={},
                        _resolve_conflict_map={},
                    )

            result.append(keyed_tuple(newrow))

        return frozen_result.with_new_rows(result)
    finally:
        session.autoflush = autoflush


@util.became_legacy_20(
    ":func:`_orm.merge_result`",
    alternative="The function as well as the method on :class:`_orm.Query` "
    "is superseded by the :func:`_orm.merge_frozen_result` function.",
)
@util.preload_module("sqlalchemy.orm.context")
def merge_result(
    query: Query[Any],
    iterator: Union[FrozenResult, Iterable[Sequence[Any]], Iterable[object]],
    load: bool = True,
) -> Union[FrozenResult, Iterable[Any]]:
    """Merge a result into the given :class:`.Query` object's Session.

    See :meth:`_orm.Query.merge_result` for top-level documentation on this
    function.

    """

    querycontext = util.preloaded.orm_context

    session = query.session
    if load:

        session._autoflush()



    if isinstance(iterator, FrozenResult):
        frozen_result = iterator
        iterator = iter(frozen_result.data)
    else:
        frozen_result = None

    ctx = querycontext.ORMSelectCompileState._create_entities_collection(
        query, legacy=True
    )

    autoflush = session.autoflush
    try:
        session.autoflush = False
        single_entity = not frozen_result and len(ctx._entities) == 1

        if single_entity:
            if isinstance(ctx._entities[0], querycontext._MapperEntity):
                result = [
                    session._merge(
                        attributes.instance_state(instance),
                        attributes.instance_dict(instance),
                        load=load,
                        _recursive={},
                        _resolve_conflict_map={},
                    )
                    for instance in iterator
                ]
            else:
                result = list(iterator)
        else:
            mapped_entities = [
                i
                for i, e in enumerate(ctx._entities)
                if isinstance(e, querycontext._MapperEntity)
            ]
            result = []
            keys = [ent._label_name for ent in ctx._entities]

            keyed_tuple = result_tuple(
                keys, [ent._extra_entities for ent in ctx._entities]
            )

            for row in iterator:
                newrow = list(row)
                for i in mapped_entities:
                    if newrow[i] is not None:
                        newrow[i] = session._merge(
                            attributes.instance_state(newrow[i]),
                            attributes.instance_dict(newrow[i]),
                            load=load,
                            _recursive={},
                            _resolve_conflict_map={},
                        )
                result.append(keyed_tuple(newrow))

        if frozen_result:
            return frozen_result.with_new_rows(result)
        else:
            return iter(result)
    finally:
        session.autoflush = autoflush


def get_from_identity(
    session: Session,
    mapper: Mapper[_O],
    key: _IdentityKeyType[_O],
    passive: PassiveFlag,
) -> Union[LoaderCallableStatus, Optional[_O]]:
    """Look up the given key in the given session's identity map,
    check the object for expired state if found.

    """
    instance = session.identity_map.get(key)
    if instance is not None:
        state = attributes.instance_state(instance)

        if mapper.inherits and not state.mapper.isa(mapper):
            return attributes.PASSIVE_CLASS_MISMATCH


        if state.expired:
            if not passive & attributes.SQL_OK:

                return attributes.PASSIVE_NO_RESULT
            elif not passive & attributes.RELATED_OBJECT_OK:




                return instance
            try:
                state._load_expired(state, passive)
            except orm_exc.ObjectDeletedError:
                session._remove_newly_deleted([state])
                return None
        return instance
    else:
        return None


def load_on_ident(
    session: Session,
    statement: Union[Select, FromStatement],
    key: Optional[_IdentityKeyType],
    *,
    load_options: Optional[Sequence[ORMOption]] = None,
    refresh_state: Optional[InstanceState[Any]] = None,
    with_for_update: Optional[ForUpdateArg] = None,
    only_load_props: Optional[Iterable[str]] = None,
    no_autoflush: bool = False,
    bind_arguments: Mapping[str, Any] = util.EMPTY_DICT,
    execution_options: _ExecuteOptions = util.EMPTY_DICT,
    require_pk_cols: bool = False,
    is_user_refresh: bool = False,
):
    """Load the given identity key from the database."""
    if key is not None:
        ident = key[1]
        identity_token = key[2]
    else:
        ident = identity_token = None

    return load_on_pk_identity(
        session,
        statement,
        ident,
        load_options=load_options,
        refresh_state=refresh_state,
        with_for_update=with_for_update,
        only_load_props=only_load_props,
        identity_token=identity_token,
        no_autoflush=no_autoflush,
        bind_arguments=bind_arguments,
        execution_options=execution_options,
        require_pk_cols=require_pk_cols,
        is_user_refresh=is_user_refresh,
    )


def load_on_pk_identity(
    session: Session,
    statement: Union[Select, FromStatement],
    primary_key_identity: Optional[Tuple[Any, ...]],
    *,
    load_options: Optional[Sequence[ORMOption]] = None,
    refresh_state: Optional[InstanceState[Any]] = None,
    with_for_update: Optional[ForUpdateArg] = None,
    only_load_props: Optional[Iterable[str]] = None,
    identity_token: Optional[Any] = None,
    no_autoflush: bool = False,
    bind_arguments: Mapping[str, Any] = util.EMPTY_DICT,
    execution_options: _ExecuteOptions = util.EMPTY_DICT,
    require_pk_cols: bool = False,
    is_user_refresh: bool = False,
):
    """Load the given primary key identity from the database."""

    query = statement
    q = query._clone()

    assert not q._is_lambda_element

    if load_options is None:
        load_options = QueryContext.default_load_options

    if (
        statement._compile_options
        is SelectState.default_select_compile_options
    ):
        compile_options = ORMCompileState.default_compile_options
    else:
        compile_options = statement._compile_options

    if primary_key_identity is not None:
        mapper = query._propagate_attrs["plugin_subject"]

        (_get_clause, _get_params) = mapper._get_clause



        if None in primary_key_identity:
            nones = {
                _get_params[col].key
                for col, value in zip(mapper.primary_key, primary_key_identity)
                if value is None
            }

            _get_clause = sql_util.adapt_criterion_to_null(_get_clause, nones)

            if len(nones) == len(primary_key_identity):
                util.warn(
                    "fully NULL primary key identity cannot load any "
                    "object.  This condition may raise an error in a future "
                    "release."
                )

        q._where_criteria = (
            sql_util._deep_annotate(_get_clause, {"_orm_adapt": True}),
        )

        params = {
            _get_params[primary_key].key: id_val
            for id_val, primary_key in zip(
                primary_key_identity, mapper.primary_key
            )
        }
    else:
        params = None

    if with_for_update is not None:
        version_check = True
        q._for_update_arg = with_for_update
    elif query._for_update_arg is not None:
        version_check = True
        q._for_update_arg = query._for_update_arg
    else:
        version_check = False

    if require_pk_cols and only_load_props:
        if not refresh_state:
            raise sa_exc.ArgumentError(
                "refresh_state is required when require_pk_cols is present"
            )

        refresh_state_prokeys = refresh_state.mapper._primary_key_propkeys
        has_changes = {
            key
            for key in refresh_state_prokeys.difference(only_load_props)
            if refresh_state.attrs[key].history.has_changes()
        }
        if has_changes:












            raise sa_exc.InvalidRequestError(
                f"Please flush pending primary key changes on "
                "attributes "
                f"{has_changes} for mapper {refresh_state.mapper} before "
                "proceeding with a refresh"
            )




























        mp = refresh_state.mapper._props
        for p in only_load_props:
            if mp[p]._is_relationship:
                only_load_props = refresh_state_prokeys.union(only_load_props)
                break

    if refresh_state and refresh_state.load_options:
        compile_options += {"_current_path": refresh_state.load_path.parent}
        q = q.options(*refresh_state.load_options)

    new_compile_options, load_options = _set_get_options(
        compile_options,
        load_options,
        version_check=version_check,
        only_load_props=only_load_props,
        refresh_state=refresh_state,
        identity_token=identity_token,
        is_user_refresh=is_user_refresh,
    )

    q._compile_options = new_compile_options
    q._order_by = None

    if no_autoflush:
        load_options += {"_autoflush": False}

    execution_options = util.EMPTY_DICT.merge_with(
        execution_options, {"_sa_orm_load_options": load_options}
    )
    result = (
        session.execute(
            q,
            params=params,
            execution_options=execution_options,
            bind_arguments=bind_arguments,
        )
        .unique()
        .scalars()
    )

    try:
        return result.one()
    except orm_exc.NoResultFound:
        return None


def _set_get_options(
    compile_opt,
    load_opt,
    populate_existing=None,
    version_check=None,
    only_load_props=None,
    refresh_state=None,
    identity_token=None,
    is_user_refresh=None,
):
    compile_options = {}
    load_options = {}
    if version_check:
        load_options["_version_check"] = version_check
    if populate_existing:
        load_options["_populate_existing"] = populate_existing
    if refresh_state:
        load_options["_refresh_state"] = refresh_state
        compile_options["_for_refresh_state"] = True
    if only_load_props:
        compile_options["_only_load_props"] = frozenset(only_load_props)
    if identity_token:
        load_options["_identity_token"] = identity_token

    if is_user_refresh:
        load_options["_is_user_refresh"] = is_user_refresh
    if load_options:
        load_opt += load_options
    if compile_options:
        compile_opt += compile_options

    return compile_opt, load_opt


def _setup_entity_query(
    compile_state,
    mapper,
    query_entity,
    path,
    adapter,
    column_collection,
    with_polymorphic=None,
    only_load_props=None,
    polymorphic_discriminator=None,
    **kw,
):
    if with_polymorphic:
        poly_properties = mapper._iterate_polymorphic_properties(
            with_polymorphic
        )
    else:
        poly_properties = mapper._polymorphic_properties

    quick_populators = {}

    path.set(compile_state.attributes, "memoized_setups", quick_populators)





    check_for_adapt = adapter and len(path) == 1 and path[-1].is_aliased_class

    for value in poly_properties:
        if only_load_props and value.key not in only_load_props:
            continue
        value.setup(
            compile_state,
            query_entity,
            path,
            adapter,
            only_load_props=only_load_props,
            column_collection=column_collection,
            memoized_populators=quick_populators,
            check_for_adapt=check_for_adapt,
            **kw,
        )

    if (
        polymorphic_discriminator is not None
        and polymorphic_discriminator is not mapper.polymorphic_on
    ):
        if adapter:
            pd = adapter.columns[polymorphic_discriminator]
        else:
            pd = polymorphic_discriminator
        column_collection.append(pd)


def _warn_for_runid_changed(state):
    util.warn(
        "Loading context for %s has changed within a load/refresh "
        "handler, suggesting a row refresh operation took place. If this "
        "event handler is expected to be "
        "emitting row refresh operations within an existing load or refresh "
        "operation, set restore_load_context=True when establishing the "
        "listener to ensure the context remains unchanged when the event "
        "handler completes." % (state_str(state),)
    )


def _instance_processor(
    query_entity,
    mapper,
    context,
    result,
    path,
    adapter,
    only_load_props=None,
    refresh_state=None,
    polymorphic_discriminator=None,
    _polymorphic_from=None,
):
    """Produce a mapper level row processor callable
    which processes rows into mapped instances."""







    identity_class = mapper._identity_class
    compile_state = context.compile_state






    getter_key = ("getters", mapper)
    getters = path.get(compile_state.attributes, getter_key, None)

    if getters is None:







        props = mapper._prop_set
        if only_load_props is not None:
            props = props.intersection(
                mapper._props[k] for k in only_load_props
            )

        quick_populators = path.get(
            context.attributes, "memoized_setups", EMPTY_DICT
        )

        todo = []
        cached_populators = {
            "new": [],
            "quick": [],
            "deferred": [],
            "expire": [],
            "existing": [],
            "eager": [],
        }

        if refresh_state is None:

            pk_cols = mapper.primary_key

            if adapter:
                pk_cols = [adapter.columns[c] for c in pk_cols]
            primary_key_getter = result._tuple_getter(pk_cols)
        else:
            primary_key_getter = None

        getters = {
            "cached_populators": cached_populators,
            "todo": todo,
            "primary_key_getter": primary_key_getter,
        }
        for prop in props:
            if prop in quick_populators:

                col = quick_populators[prop]
                if col is _DEFER_FOR_STATE:
                    cached_populators["new"].append(
                        (prop.key, prop._deferred_column_loader)
                    )
                elif col is _SET_DEFERRED_EXPIRED:



                    cached_populators["expire"].append((prop.key, False))
                elif col is _RAISE_FOR_STATE:
                    cached_populators["new"].append(
                        (prop.key, prop._raise_column_loader)
                    )
                else:
                    getter = None
                    if adapter:




















                        adapted_col = adapter.columns[col]
                        if adapted_col is not None:
                            getter = result._getter(adapted_col, False)
                    if not getter:
                        getter = result._getter(col, False)
                    if getter:
                        cached_populators["quick"].append((prop.key, getter))
                    else:



                        prop.create_row_processor(
                            context,
                            query_entity,
                            path,
                            mapper,
                            result,
                            adapter,
                            cached_populators,
                        )
            else:



                todo.append(prop)

        path.set(compile_state.attributes, getter_key, getters)

    cached_populators = getters["cached_populators"]

    populators = {key: list(value) for key, value in cached_populators.items()}
    for prop in getters["todo"]:
        prop.create_row_processor(
            context, query_entity, path, mapper, result, adapter, populators
        )

    propagated_loader_options = context.propagated_loader_options
    load_path = (
        context.compile_state.current_path + path
        if context.compile_state.current_path.path
        else path
    )

    session_identity_map = context.session.identity_map

    populate_existing = context.populate_existing or mapper.always_refresh
    load_evt = bool(mapper.class_manager.dispatch.load)
    refresh_evt = bool(mapper.class_manager.dispatch.refresh)
    persistent_evt = bool(context.session.dispatch.loaded_as_persistent)
    if persistent_evt:
        loaded_as_persistent = context.session.dispatch.loaded_as_persistent
    instance_state = attributes.instance_state
    instance_dict = attributes.instance_dict
    session_id = context.session.hash_key
    runid = context.runid
    identity_token = context.identity_token

    version_check = context.version_check
    if version_check:
        version_id_col = mapper.version_id_col
        if version_id_col is not None:
            if adapter:
                version_id_col = adapter.columns[version_id_col]
            version_id_getter = result._getter(version_id_col)
        else:
            version_id_getter = None

    if not refresh_state and _polymorphic_from is not None:
        key = ("loader", path.path)

        if key in context.attributes and context.attributes[key].strategy == (
            ("selectinload_polymorphic", True),
        ):
            option_entities = context.attributes[key].local_opts["entities"]
        else:
            option_entities = None
        selectin_load_via = mapper._should_selectin_load(
            option_entities,
            _polymorphic_from,
        )

        if selectin_load_via and selectin_load_via is not _polymorphic_from:



            assert only_load_props is None

            if selectin_load_via.is_mapper:
                _load_supers = []
                _endmost_mapper = selectin_load_via
                while (
                    _endmost_mapper
                    and _endmost_mapper is not _polymorphic_from
                ):
                    _load_supers.append(_endmost_mapper)
                    _endmost_mapper = _endmost_mapper.inherits
            else:
                _load_supers = [selectin_load_via]

            for _selectinload_entity in _load_supers:
                if PostLoad.path_exists(
                    context, load_path, _selectinload_entity
                ):
                    continue
                callable_ = _load_subclass_via_in(
                    context,
                    path,
                    _selectinload_entity,
                    _polymorphic_from,
                    option_entities,
                )
                PostLoad.callable_for_path(
                    context,
                    load_path,
                    _selectinload_entity.mapper,
                    _selectinload_entity,
                    callable_,
                    _selectinload_entity,
                )

    post_load = PostLoad.for_context(context, load_path, only_load_props)

    if refresh_state:
        refresh_identity_key = refresh_state.key
        if refresh_identity_key is None:



            refresh_identity_key = mapper._identity_key_from_state(
                refresh_state
            )
    else:
        refresh_identity_key = None

        primary_key_getter = getters["primary_key_getter"]

    if mapper.allow_partial_pks:
        is_not_primary_key = _none_set.issuperset
    else:
        is_not_primary_key = _none_set.intersection

    def _instance(row):

        if refresh_identity_key:

            state = refresh_state
            instance = state.obj()
            dict_ = instance_dict(instance)
            isnew = state.runid != runid
            currentload = True
            loaded_instance = False
        else:


            identitykey = (
                identity_class,
                primary_key_getter(row),
                identity_token,
            )

            instance = session_identity_map.get(identitykey)

            if instance is not None:

                state = instance_state(instance)
                dict_ = instance_dict(instance)

                isnew = state.runid != runid
                currentload = not isnew
                loaded_instance = False

                if version_check and version_id_getter and not currentload:
                    _validate_version_id(
                        mapper, state, dict_, row, version_id_getter
                    )

            else:




                if is_not_primary_key(identitykey[1]):
                    return None

                isnew = True
                currentload = True
                loaded_instance = True

                instance = mapper.class_manager.new_instance()

                dict_ = instance_dict(instance)
                state = instance_state(instance)
                state.key = identitykey
                state.identity_token = identity_token


                state.session_id = session_id
                session_identity_map._add_unpresent(state, identitykey)

        effective_populate_existing = populate_existing
        if refresh_state is state:
            effective_populate_existing = True




        if currentload or effective_populate_existing:






            if isnew and (
                propagated_loader_options or not effective_populate_existing
            ):
                state.load_options = propagated_loader_options
                state.load_path = load_path

            _populate_full(
                context,
                row,
                state,
                dict_,
                isnew,
                load_path,
                loaded_instance,
                effective_populate_existing,
                populators,
            )

            if isnew:





                existing_runid = state.runid

                if loaded_instance:
                    if load_evt:
                        state.manager.dispatch.load(state, context)
                        if state.runid != existing_runid:
                            _warn_for_runid_changed(state)
                    if persistent_evt:
                        loaded_as_persistent(context.session, state)
                        if state.runid != existing_runid:
                            _warn_for_runid_changed(state)
                elif refresh_evt:
                    state.manager.dispatch.refresh(
                        state, context, only_load_props
                    )
                    if state.runid != runid:
                        _warn_for_runid_changed(state)

                if effective_populate_existing or state.modified:
                    if refresh_state and only_load_props:
                        state._commit(dict_, only_load_props)
                    else:
                        state._commit_all(dict_, session_identity_map)

            if post_load:
                post_load.add_state(state, True)

        else:



            unloaded = state.unloaded
            isnew = state not in context.partials

            if not isnew or unloaded or populators["eager"]:




                to_load = _populate_partial(
                    context,
                    row,
                    state,
                    dict_,
                    isnew,
                    load_path,
                    unloaded,
                    populators,
                )

                if isnew:
                    if refresh_evt:
                        existing_runid = state.runid
                        state.manager.dispatch.refresh(state, context, to_load)
                        if state.runid != existing_runid:
                            _warn_for_runid_changed(state)

                    state._commit(dict_, to_load)

            if post_load and context.invoke_all_eagers:
                post_load.add_state(state, False)

        return instance

    if mapper.polymorphic_map and not _polymorphic_from and not refresh_state:


        def ensure_no_pk(row):
            identitykey = (
                identity_class,
                primary_key_getter(row),
                identity_token,
            )
            if not is_not_primary_key(identitykey[1]):
                return identitykey
            else:
                return None

        _instance = _decorate_polymorphic_switch(
            _instance,
            context,
            query_entity,
            mapper,
            result,
            path,
            polymorphic_discriminator,
            adapter,
            ensure_no_pk,
        )

    return _instance


def _load_subclass_via_in(
    context, path, entity, polymorphic_from, option_entities
):
    mapper = entity.mapper




    polymorphic_from_mapper = polymorphic_from.mapper
    not_against_basemost = polymorphic_from_mapper.inherits is not None

    zero_idx = len(mapper.base_mapper.primary_key) == 1

    if entity.is_aliased_class or not_against_basemost:
        q, enable_opt, disable_opt = mapper._subclass_load_via_in(
            entity, polymorphic_from
        )
    else:
        q, enable_opt, disable_opt = mapper._subclass_load_via_in_mapper

    def do_load(context, path, states, load_only, effective_entity):
        if not option_entities:





            states = [
                (s, v)
                for s, v in states
                if s.mapper._would_selectin_load_only_from_given_mapper(mapper)
            ]

            if not states:
                return

        orig_query = context.query

        if path.parent:
            enable_opt_lcl = enable_opt._prepend_path(path)
            disable_opt_lcl = disable_opt._prepend_path(path)
        else:
            enable_opt_lcl = enable_opt
            disable_opt_lcl = disable_opt
        options = (
            (enable_opt_lcl,) + orig_query._with_options + (disable_opt_lcl,)
        )

        q2 = q.options(*options)

        q2._compile_options = context.compile_state.default_compile_options
        q2._compile_options += {"_current_path": path.parent}

        if context.populate_existing:
            q2 = q2.execution_options(populate_existing=True)

        context.session.execute(
            q2,
            dict(
                primary_keys=[
                    state.key[1][0] if zero_idx else state.key[1]
                    for state, load_attrs in states
                ]
            ),
        ).unique().scalars().all()

    return do_load


def _populate_full(
    context,
    row,
    state,
    dict_,
    isnew,
    load_path,
    loaded_instance,
    populate_existing,
    populators,
):
    if isnew:

        state.runid = context.runid

        for key, getter in populators["quick"]:
            dict_[key] = getter(row)
        if populate_existing:
            for key, set_callable in populators["expire"]:
                dict_.pop(key, None)
                if set_callable:
                    state.expired_attributes.add(key)
        else:
            for key, set_callable in populators["expire"]:
                if set_callable:
                    state.expired_attributes.add(key)

        for key, populator in populators["new"]:
            populator(state, dict_, row)

    elif load_path != state.load_path:


        state.load_path = load_path



        for key, getter in populators["quick"]:
            if key not in dict_:
                dict_[key] = getter(row)


        for key, populator in populators["existing"]:
            populator(state, dict_, row)




    else:

        for key, populator in populators["existing"]:
            populator(state, dict_, row)





def _populate_partial(
    context, row, state, dict_, isnew, load_path, unloaded, populators
):
    if not isnew:
        if unloaded:

            for key, getter in populators["quick"]:
                if key in unloaded:
                    dict_[key] = getter(row)

        to_load = context.partials[state]
        for key, populator in populators["existing"]:
            if key in to_load:
                populator(state, dict_, row)
    else:
        to_load = unloaded
        context.partials[state] = to_load

        for key, getter in populators["quick"]:
            if key in to_load:
                dict_[key] = getter(row)
        for key, set_callable in populators["expire"]:
            if key in to_load:
                dict_.pop(key, None)
                if set_callable:
                    state.expired_attributes.add(key)
        for key, populator in populators["new"]:
            if key in to_load:
                populator(state, dict_, row)

    for key, populator in populators["eager"]:
        if key not in unloaded:
            populator(state, dict_, row)

    return to_load


def _validate_version_id(mapper, state, dict_, row, getter):
    if mapper._get_state_attr_by_column(
        state, dict_, mapper.version_id_col
    ) != getter(row):
        raise orm_exc.StaleDataError(
            "Instance '%s' has version id '%s' which "
            "does not match database-loaded version id '%s'."
            % (
                state_str(state),
                mapper._get_state_attr_by_column(
                    state, dict_, mapper.version_id_col
                ),
                getter(row),
            )
        )


def _decorate_polymorphic_switch(
    instance_fn,
    context,
    query_entity,
    mapper,
    result,
    path,
    polymorphic_discriminator,
    adapter,
    ensure_no_pk,
):
    if polymorphic_discriminator is not None:
        polymorphic_on = polymorphic_discriminator
    else:
        polymorphic_on = mapper.polymorphic_on
    if polymorphic_on is None:
        return instance_fn

    if adapter:
        polymorphic_on = adapter.columns[polymorphic_on]

    def configure_subclass_mapper(discriminator):
        try:
            sub_mapper = mapper.polymorphic_map[discriminator]
        except KeyError:
            raise AssertionError(
                "No such polymorphic_identity %r is defined" % discriminator
            )
        else:
            if sub_mapper is mapper:
                return None
            elif not sub_mapper.isa(mapper):
                return False

            return _instance_processor(
                query_entity,
                sub_mapper,
                context,
                result,
                path,
                adapter,
                _polymorphic_from=mapper,
            )

    polymorphic_instances = util.PopulateDict(configure_subclass_mapper)

    getter = result._getter(polymorphic_on)

    def polymorphic_instance(row):
        discriminator = getter(row)
        if discriminator is not None:
            _instance = polymorphic_instances[discriminator]
            if _instance:
                return _instance(row)
            elif _instance is False:
                identitykey = ensure_no_pk(row)

                if identitykey:
                    raise sa_exc.InvalidRequestError(
                        "Row with identity key %s can't be loaded into an "
                        "object; the polymorphic discriminator column '%s' "
                        "refers to %s, which is not a sub-mapper of "
                        "the requested %s"
                        % (
                            identitykey,
                            polymorphic_on,
                            mapper.polymorphic_map[discriminator],
                            mapper,
                        )
                    )
                else:
                    return None
            else:
                return instance_fn(row)
        else:
            identitykey = ensure_no_pk(row)

            if identitykey:
                raise sa_exc.InvalidRequestError(
                    "Row with identity key %s can't be loaded into an "
                    "object; the polymorphic discriminator column '%s' is "
                    "NULL" % (identitykey, polymorphic_on)
                )
            else:
                return None

    return polymorphic_instance


class PostLoad:
    """Track loaders and states for "post load" operations."""

    __slots__ = "loaders", "states", "load_keys"

    def __init__(self):
        self.loaders = {}
        self.states = util.OrderedDict()
        self.load_keys = None

    def add_state(self, state, overwrite):




        self.states[state] = overwrite

    def invoke(self, context, path):
        if not self.states:
            return
        path = path_registry.PathRegistry.coerce(path)
        for (
            effective_context,
            token,
            limit_to_mapper,
            loader,
            arg,
            kw,
        ) in self.loaders.values():
            states = [
                (state, overwrite)
                for state, overwrite in self.states.items()
                if state.manager.mapper.isa(limit_to_mapper)
            ]
            if states:
                loader(
                    effective_context, path, states, self.load_keys, *arg, **kw
                )
        self.states.clear()

    @classmethod
    def for_context(cls, context, path, only_load_props):
        pl = context.post_load_paths.get(path.path)
        if pl is not None and only_load_props:
            pl.load_keys = only_load_props
        return pl

    @classmethod
    def path_exists(self, context, path, key):
        return (
            path.path in context.post_load_paths
            and key in context.post_load_paths[path.path].loaders
        )

    @classmethod
    def callable_for_path(
        cls, context, path, limit_to_mapper, token, loader_callable, *arg, **kw
    ):
        if path.path in context.post_load_paths:
            pl = context.post_load_paths[path.path]
        else:
            pl = context.post_load_paths[path.path] = PostLoad()
        pl.loaders[token] = (
            context,
            token,
            limit_to_mapper,
            loader_callable,
            arg,
            kw,
        )


def load_scalar_attributes(mapper, state, attribute_names, passive):
    """initiate a column-based attribute refresh operation."""


    session = state.session
    if not session:
        raise orm_exc.DetachedInstanceError(
            "Instance %s is not bound to a Session; "
            "attribute refresh operation cannot proceed" % (state_str(state))
        )

    no_autoflush = bool(passive & attributes.NO_AUTOFLUSH)







    if attribute_names:
        attribute_names = attribute_names.intersection(mapper.attrs.keys())

    if mapper.inherits and not mapper.concrete:



        statement = mapper._optimized_get_statement(state, attribute_names)
        if statement is not None:


            stmt = FromStatement(mapper, statement)

            return load_on_ident(
                session,
                stmt,
                None,
                only_load_props=attribute_names,
                refresh_state=state,
                no_autoflush=no_autoflush,
            )


    has_key = bool(state.key)

    if has_key:
        identity_key = state.key
    else:




        pk_attrs = [
            mapper._columntoproperty[col].key for col in mapper.primary_key
        ]
        if state.expired_attributes.intersection(pk_attrs):
            raise sa_exc.InvalidRequestError(
                "Instance %s cannot be refreshed - it's not "
                " persistent and does not "
                "contain a full primary key." % state_str(state)
            )
        identity_key = mapper._identity_key_from_state(state)

    if (
        _none_set.issubset(identity_key) and not mapper.allow_partial_pks
    ) or _none_set.issuperset(identity_key):
        util.warn_limited(
            "Instance %s to be refreshed doesn't "
            "contain a full primary key - can't be refreshed "
            "(and shouldn't be expired, either).",
            state_str(state),
        )
        return

    result = load_on_ident(
        session,
        select(mapper).set_label_style(LABEL_STYLE_TABLENAME_PLUS_COL),
        identity_key,
        refresh_state=state,
        only_load_props=attribute_names,
        no_autoflush=no_autoflush,
    )



    if has_key and result is None:
        raise orm_exc.ObjectDeletedError(state)
